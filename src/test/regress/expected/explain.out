--
-- EXPLAIN
--
-- helper functions for examining explain output
-- return a json explain of given query
CREATE OR REPLACE FUNCTION json_explain(query text, variadic opts text[])
  RETURNS json LANGUAGE PLPGSQL AS $$
DECLARE
  plan json;
BEGIN
  EXECUTE 'EXPLAIN (' || array_to_string(array_append(opts, 'FORMAT JSON) '), ', ') || query INTO STRICT plan;
  RETURN plan;
END;
$$;
-- return a text explain of given query
CREATE OR REPLACE FUNCTION text_explain(query text, variadic opts text[])
  RETURNS text LANGUAGE PLPGSQL AS $$
DECLARE
  plan_row RECORD;
  plan text = '';
BEGIN
  FOR plan_row IN EXECUTE 'EXPLAIN (' || array_to_string(array_append(opts, 'FORMAT TEXT) '), ', ') || query LOOP
    plan = plan || plan_row."QUERY PLAN" || E'\n';
  END LOOP;

  RETURN plan;
END;
$$;
/*
 * Takes a json object and processes its keys and values. For every
 * matching key whose value is a number, set it to zero to facilitate
 * comparisons for values that can vary across executions. If not a number,
 * set the value to -1 to indicate we matched an unexpected key. Return
 * non-matching keys and values unmodified.
 */
CREATE OR REPLACE FUNCTION json_normalize_numeric_keys_matching(obj json, regexp text)
  RETURNS json LANGUAGE SQL AS $$
SELECT
  coalesce(json_object_agg(
    key,
    CASE
      WHEN key ~ regexp THEN
        CASE json_typeof(value)
	  WHEN 'number' THEN 0::text::json
	  ELSE (-1)::text::json
	END
      ELSE value
    END
  ), '{}')
FROM
  json_each(obj)
$$;
-- explain only worker information, normalizing any values that could vary across executions
CREATE OR REPLACE FUNCTION explain_workers(plan_node json)
  RETURNS json LANGUAGE SQL AS $$
SELECT
  coalesce(json_object_agg(key, value), '{}')
FROM (
  SELECT
    key,
    CASE key
      WHEN 'Workers' THEN
        (SELECT json_agg(
	   json_normalize_numeric_keys_matching(worker, '(Blocks|Time)$|Sort Space Used')
        )
        FROM json_array_elements(value) AS workers(worker))
      WHEN 'Plans' THEN
	(SELECT json_agg(
	  explain_workers(child)
	)
	FROM json_array_elements(value) AS children(child))
    END AS value
  FROM
    json_each(plan_node) AS entries(key, value)
  WHERE
    key IN ('Workers', 'Plans')
) AS plan_fields(key, value);
$$;
-- test that per-worker sort and buffers output is combined correctly in EXPLAIN
set force_parallel_mode = true;
SELECT explain_workers(json_explain($$
  SELECT * FROM (VALUES(1),(2)) x ORDER BY x;
$$, 'verbose', 'analyze', 'buffers') -> 0 -> 'Plan');
                                                                                                                                                                                                                                                                                                                                                                                                                                                              explain_workers                                                                                                                                                                                                                                                                                                                                                                                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 { "Plans" : [{ "Workers" : [{ "Worker Number" : 0, "Actual Startup Time" : 0, "Actual Total Time" : 0, "Actual Rows" : 2, "Actual Loops" : 1, "Sort Method" : "quicksort", "Sort Space Used" : 0, "Sort Space Type" : "Memory", "Shared Hit Blocks" : 0, "Shared Read Blocks" : 0, "Shared Dirtied Blocks" : 0, "Shared Written Blocks" : 0, "Local Hit Blocks" : 0, "Local Read Blocks" : 0, "Local Dirtied Blocks" : 0, "Local Written Blocks" : 0, "Temp Read Blocks" : 0, "Temp Written Blocks" : 0 }], "Plans" : [{ "Workers" : [{ "Worker Number" : 0, "Actual Startup Time" : 0, "Actual Total Time" : 0, "Actual Rows" : 2, "Actual Loops" : 1, "Shared Hit Blocks" : 0, "Shared Read Blocks" : 0, "Shared Dirtied Blocks" : 0, "Shared Written Blocks" : 0, "Local Hit Blocks" : 0, "Local Read Blocks" : 0, "Local Dirtied Blocks" : 0, "Local Written Blocks" : 0, "Temp Read Blocks" : 0, "Temp Written Blocks" : 0 }] }] }] }
(1 row)

SELECT regexp_replace(regexp_replace(text_explain($$
  SELECT * FROM (VALUES(1),(2)) x ORDER BY x;
$$, 'verbose', 'analyze', 'buffers', 'timing off', 'costs off', 'summary off'),
  'Buffers:.+$', 'Buffers: xxx', 'ng'), 'Sort Method:.+$', 'Sort Method: xxx', 'ng');
                          regexp_replace                           
-------------------------------------------------------------------
 Gather (actual rows=2 loops=1)                                   +
   Output: "*VALUES*".column1, (ROW("*VALUES*".column1))          +
   Workers Planned: 1                                             +
   Workers Launched: 1                                            +
   Single Copy: true                                              +
   Buffers: xxx                                                   +
   ->  Sort (actual rows=2 loops=1)                               +
         Output: "*VALUES*".column1, (ROW("*VALUES*".column1))    +
         Sort Key: (ROW("*VALUES*".column1))                      +
         Buffers: xxx                                             +
         Worker 0: actual rows=2 loops=1                          +
           Sort Method: xxx                                       +
           Buffers: xxx                                           +
         ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)    +
               Output: "*VALUES*".column1, ROW("*VALUES*".column1)+
               Worker 0: actual rows=2 loops=1                    +
 
(1 row)

reset force_parallel_mode;
